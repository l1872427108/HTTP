<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP进化史 | HTTP</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/http/assets/css/0.styles.a82bc65d.css" as="style"><link rel="preload" href="/http/assets/js/app.a9f7748e.js" as="script"><link rel="preload" href="/http/assets/js/2.fdc7410f.js" as="script"><link rel="preload" href="/http/assets/js/26.7f50fc9d.js" as="script"><link rel="prefetch" href="/http/assets/js/10.175862a4.js"><link rel="prefetch" href="/http/assets/js/11.da069018.js"><link rel="prefetch" href="/http/assets/js/12.93495841.js"><link rel="prefetch" href="/http/assets/js/13.8448399c.js"><link rel="prefetch" href="/http/assets/js/14.19259a4b.js"><link rel="prefetch" href="/http/assets/js/15.a5b6314d.js"><link rel="prefetch" href="/http/assets/js/16.f63eb92b.js"><link rel="prefetch" href="/http/assets/js/17.96dea844.js"><link rel="prefetch" href="/http/assets/js/18.23de83c2.js"><link rel="prefetch" href="/http/assets/js/19.3e2f9e36.js"><link rel="prefetch" href="/http/assets/js/20.ce055c61.js"><link rel="prefetch" href="/http/assets/js/21.9467c730.js"><link rel="prefetch" href="/http/assets/js/22.864cf96f.js"><link rel="prefetch" href="/http/assets/js/23.2ebd0b41.js"><link rel="prefetch" href="/http/assets/js/24.dc92fb3e.js"><link rel="prefetch" href="/http/assets/js/25.8a742a4a.js"><link rel="prefetch" href="/http/assets/js/27.1f4ad5a3.js"><link rel="prefetch" href="/http/assets/js/28.90b361f2.js"><link rel="prefetch" href="/http/assets/js/29.a5d3a86b.js"><link rel="prefetch" href="/http/assets/js/3.039192e6.js"><link rel="prefetch" href="/http/assets/js/4.bc7cf726.js"><link rel="prefetch" href="/http/assets/js/5.d250cb53.js"><link rel="prefetch" href="/http/assets/js/6.8779df89.js"><link rel="prefetch" href="/http/assets/js/7.ed1d2405.js"><link rel="prefetch" href="/http/assets/js/8.00f43ad9.js"><link rel="prefetch" href="/http/assets/js/9.e1c59f60.js">
    <link rel="stylesheet" href="/http/assets/css/0.styles.a82bc65d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/http/" class="home-link router-link-active"><!----> <span class="site-name">HTTP</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/http/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/l1872427108/uui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.npmjs.com/package/uu-uui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Npm
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/http/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/l1872427108/uui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.npmjs.com/package/uu-uui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Npm
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/http/componentDocs/HTTP报文结构.html" class="sidebar-link">HTTP 报文结构</a></li><li><a href="/http/componentDocs/HTTP请求方法.html" class="sidebar-link">HTTP 请求方法</a></li><li><a href="/http/componentDocs/URI.html" class="sidebar-link">如何理解 URI？</a></li><li><a href="/http/componentDocs/HTTP状态码.html" class="sidebar-link">HTTP 状态码</a></li><li><a href="/http/componentDocs/HTTP特点.html" class="sidebar-link">HTTP 的特点。</a></li><li><a href="/http/componentDocs/Accept.html" class="sidebar-link">Accept</a></li><li><a href="/http/componentDocs/HTTP 怎么传输定长和不定长的数据.html" class="sidebar-link">HTTP 怎么传输定长和不定长的数据</a></li><li><a href="/http/componentDocs/HTTP处理大文件的传输.html" class="sidebar-link">HTTP 处理大文件的传输</a></li><li><a href="/http/componentDocs/HTTP处理表单数据的提交.html" class="sidebar-link">HTTP 处理表单数据的提交</a></li><li><a href="/http/componentDocs/HTTP1.1如何解决队头堵塞.html" class="sidebar-link">HTTP解决队头堵塞</a></li><li><a href="/http/componentDocs/Cookie.html" class="sidebar-link">Cookie和Session</a></li><li><a href="/http/componentDocs/HTTP代理.html" class="sidebar-link">HTTP代理</a></li><li><a href="/http/componentDocs/代理缓存.html" class="sidebar-link">代理缓存</a></li><li><a href="/http/componentDocs/数据如何传输.html" class="sidebar-link">数据如何传输</a></li><li><a href="/http/componentDocs/HTTP1.html" class="sidebar-link">HTTP/1</a></li><li><a href="/http/componentDocs/HTTP1.1.html" class="sidebar-link">HTTP/1.1</a></li><li><a href="/http/componentDocs/HTTP:2.0.html" class="sidebar-link">HTTP/2</a></li><li><a href="/http/componentDocs/HTTP:3.html" class="sidebar-link">HTTP/3</a></li><li><a href="/http/componentDocs/HTTPS.html" class="sidebar-link">HTTPS</a></li><li><a href="/http/componentDocs/HTTPS让数据传输更安全.html" class="sidebar-link">HTTPS让数据传输更安全</a></li></ul> </aside> <main class="page"> <div class="content__default"><h1 id="http进化史"><a href="#http进化史" class="header-anchor">#</a> HTTP进化史</h1> <h3 id="http-0-9"><a href="#http-0-9" class="header-anchor">#</a> HTTP/0.9</h3> <p>HTTP/0.9 是1991年提出的，主要用于学术交流，用来在网络之间传递 HTML 超文本的内容，因此被称为超文本传输协议。采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。</p> <ul><li>HTTP 是基于 TCP 协议的，需要客户端根据 IP、端口和服务器简历 TCP 链接。</li> <li>建立好链接之后，发松一个GET请求 GET /index.html 获取 index.html 文件。并且只允许GET请求。响应完之后关闭连接.</li> <li>作为了“原型”，验证了Web服务的可行，简单正式它的优点，易拓展和进化。</li> <li>只有一个请求行，没有 HTTP 请求头和请求体。</li> <li>服务器没有响应头。</li> <li>返回的文件是以 ASCII 字符流来传输的，都是 HTML 格式的文件，使用 ASCII 字节码来传输是最合适的。</li></ul> <h3 id="http-1-0"><a href="#http-1-0" class="header-anchor">#</a> HTTP/1.0</h3> <ol><li><p>诞生
HTTP/0.9 已经不能适用新兴网络的发展，需要一个新的协议来支持新网络，随之 HTTP/1.0诞生。</p></li> <li><p>不足
新需求：浏览器中展示的不单是 HTML 文件，还包括 JavaScript、CSS、图片、音频、视频都不同类型的文件，因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求。</p></li> <li><p>特点</p></li></ol> <ul><li>HTTP/1.0引入了请求头和相应头，是以Key-Value形式保存的，在HTTP发送请求时，会带上请求头，服务器返回数据，会返回相应头信息。</li> <li>在发起请求时会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件编码。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">accept</span><span class="token operator">:</span> text<span class="token operator">/</span>html
accept<span class="token operator">-</span>encoding<span class="token operator">:</span> gzip<span class="token punctuation">,</span> deflate<span class="token punctuation">,</span> br
accept<span class="token operator">-</span>Charset<span class="token operator">:</span> <span class="token constant">ISO</span><span class="token operator">-</span><span class="token number">8859</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>utf<span class="token operator">-</span><span class="token number">8</span>
accept<span class="token operator">-</span>language<span class="token operator">:</span> zh<span class="token operator">-</span><span class="token constant">CN</span><span class="token punctuation">,</span>zh
</code></pre></div><p>服务器根据请求头信息返回数据。并且服务器会通过相应头重的 content-encoding 告诉浏览器最终的形式。浏览器最终根据服务器返回的头信息处理数据。</p> <div class="language-js extra-class"><pre class="language-js"><code>content<span class="token operator">-</span>encoding<span class="token operator">:</span> br
content<span class="token operator">-</span>type<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset<span class="token operator">=</span><span class="token constant">UTF</span><span class="token operator">-</span><span class="token number">8</span>
</code></pre></div><ul><li>增加了状态码来通知浏览器。</li> <li>为了减轻服务器的压力，在HTTP/1.0中提供Cache机制，缓存已经下载过的数据。</li> <li>服务器需要统计客户端的基础信息，比如windows和macOS的用户数据多少，HTTP/1.0在请求头中加入用户代理字段。</li> <li>增加了 HEAD、POST等方法。</li> <li>引入了协议版本号的概念。</li></ul> <h3 id="http-1-1"><a href="#http-1-1" class="header-anchor">#</a> HTTP/1.1</h3> <ol><li><p>诞生
HTTP/1.1是一个正式的标准。意味着互联网上的所有浏览器、服务器、网关、代理等都要用到HTTP协议。</p></li> <li><p>不足</p></li></ol> <ul><li>HTTP/1.0每次HTTP通信，都需要建立TCP连接、传输HTTP数据和断开。单个页面的图片文件和外部引用太多，每次下载都需要建立，增加了开销。</li></ul> <ol start="3"><li>特点</li></ol> <ul><li>持久连接 在一个TCP连接上可以传输多个HTTP请求。减少了服务器的负担. 在1.1中默认开启。Connection： close 可以关闭。 同一个域名，可以允许同时建立6个TCP持久连接。</li> <li>HTTP 管线化 持久连接需要等待前面的请求返回之后，才能进行下一次请求。如果管道中某个请求因为某些原因没有及时返回，就会阻塞后面的请求。这就是队头阻塞问题。 HTTP/1.1试图用管线化的技术来解决队头阻塞问题。是指将多个HTTP请求整批提前交给服务器的技术，虽然可以整批的发送请求，不过服务器依然需要根据请求顺序来回复请求。</li> <li>提供虚拟主机的支持  HTTP/1.0中每个域名绑定一个唯一的IP地址，一个服务器只能支持一个域名。虚拟主机技术的发展，每个虚拟主机都要有自己的域名。公用一个IP地址。HTTP/1.1请求头中增加了Host字段，表示当前的域名地址，这样服务器就根据不同的Host做处理。</li> <li>对动态生成的内容提供支持 HTTP/1.0中，需要在相应头中设置完整的数据大小，Content-Length ，浏览器可以根据设置的数据大小来接收数据。随着服务器端的技术发展，很多页面的内容都是动态生成的。传输时不知道数据大小。 HTTP/1.1引入 Chunk transfer 机制来解决这个问题。服务器会讲数据分割成若干个任意大小的数据块，每个数据块发送时会附带上数据的长度，最后使用一个零长度的块作为发送数据完成的标志。</li> <li>客户端Cookie、安全机制。</li> <li>增加了 PUT、DELETE 等方法。</li></ul> <h3 id="http-2-0"><a href="#http-2-0" class="header-anchor">#</a> HTTP/2.0</h3> <ol><li>诞生
Chrome 开发了 Chrome，推出了新的 SPDY 协议，在 Chrome 应用自家的服务器，倒逼HTTP协议的改革。</li></ol> <p>Google 将 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 协议为基础开始制定新的版本 HTTP 协议。在 2015年发布 HTTP/2。</p> <p>HTTP/1.1为网络效率做了大量的优化，核心的有： 增加持久连接、每个域名维护6个TCP、CDN的实现域名分片机制。大大减轻了整个资源的下载时间。</p> <ol start="2"><li>不足
HTTP/1.1 对带宽的利用率不理想。
HTTP/1.1 很难将带宽用满。比如100M带宽，实际的下载速度能达到12.5M/是，而采用 HTTP/1.1，在加载页面资源时最大只能使用2.5M/S。</li></ol> <ul><li><p>TCP 的慢启动
一旦一个TCP建立好之后，就会进入发送数据状态，刚开始TCP协议会采用一个非常慢的速度发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想的状态。
慢启动是TCP为了减少网络用塞的一种策略。慢启动带来性能问题，是页面的关键资源文件本来就不大，如 HTML、CSS、JS，通常这些文件在 TCP 建立好之后就要发起请求的，但是过程是慢启动的，所以耗费的时间比正常的时间要更多，推迟了宝贵的首次渲染页面的时间了。</p></li> <li><p>同时开启了多条TCP连接，这些连接会竞争固定的带宽。
系统同时建立多条TCP连接时，当带宽充足时，每条连接发送或接收速度会慢慢向上增加。而贷款不足时，这些连接又会减慢发送或者接收的速度。
因为有的TCP连接下载的是一些关键资源，如CSS、JS文件，而不重要的图片、视频等字眼，但是多条TCP之间不能协商让哪些关键资源先下载，这样就可能影响那些关键资源的下载速度。</p></li> <li><p>HTTP/1.1队头阻塞
HTTP/1.1 中使用持久连接，虽然能够共用一个TCP管道，但是一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。
并且阻塞请求的因素有很多，并且都有一些不确定性的因素，在等待过程中，带宽、CPU都被浪费了。
浏览器其实希望提前接收到数据进行预处理操作，比如提前进行编码操作，等到需要使用图片，直接返回处理后的数据，让用户感到提升。</p></li></ul> <ol start="3"><li>特点</li></ol> <ul><li>多路复用
多路复用 HTTP/2 允许一个域名只使用一个TCP长连接来传输数据，整个页面资源的下载过程只需要一次慢启动。同时也可以避免多个TCP连接竞争带来的问题。
HTTP/2 需要实现资源的并行请求，任务时候都可以将请求发送给服务器，而不需要等待其他请求的完成；服务器也可以随时返回处理好的请求资源给浏览器。
服务器接收到这些请求后，可以优先来决定返回哪些内容，可能先发送已经缓存好的信息,先将响应头信息返回给浏览器，然后将响应体返回给浏览器；之后随意发送，因为每份数据都有对应的ID；浏览器收到，筛选出相同ID内容，拼接为完整的HTTP相应数据。
HTTP/2 使用多路复用，可以将请求分为一帧一帧数据去传输。收到优先级高的请求服务器可以优先处理。</li> <li>多路复用实现方式
HTTP/2 添加了一个二进制分帧层。浏览器发起请求。这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。服务器收到之后，会将相同ID的帧合并为一条完整的请求信息。服务器将处理的响应行、响应头和相应体分别发送到二进制分帧层。二进制分帧层将数据转为一个个带有请求ID编号的帧，经过协议栈发送给浏览器。浏览器根据 ID 编号将数据提交给对应的请求。</li></ul> <p>发送改变的只是传输方式。</p> <ul><li>设置请求的优先级 可以在发送请求时，标上该请求的优先级，服务器收到之后，就可以优先处理优先级高的请求。</li> <li>服务器推送 可以将数据提前推送到浏览器。服务器可以提前推送 HTML 附带的重要资源 CSS、Js文件。</li> <li>头部压缩 HTTP/2 对请求头和响应头进行了压缩，浏览器发送请求时，基本在发送头部信息。传输效率将大幅提升。</li> <li></li></ul> <h3 id="http-3"><a href="#http-3" class="header-anchor">#</a> HTTP/3</h3> <ol><li>背景
Google 它要“革自己的命”。 在 HTTP/2 处于草案之时，Google 发明了一个新的协议 QUIC。2018年，提议将更名为 HTTP/3 ，HTTP/3 正式进入标准化制定阶段。</li></ol> <p>HTTP/2 在 2018 年就开始得到大规模的应用，HTTP/2 的一个核心特征就是多路复用技术。多路复用能充分利用带宽，最大限度规避了TCP慢启动，头部压缩、服务器推送使得页面资源的传输得到大幅提升。浏览器只需要为一个域名维护一个TCP持久连接。</p> <ol start="2"><li>缺陷</li></ol> <ul><li>队头阻塞
HTTP/2 依然是基于 TCP 协议的，TCP的初衷就是为单连接而设计的。多个请求是跑到一个 TCP 管道中的，如果其中任意一路数据中丢包，那么就会阻塞该 TCP 连接中的所有请求。HTTP/1.1 是可以有 6 个 TCP 连接的，丢包也只是发生在具体的一个TCP 中。</li></ul> <p>随着丢包率增加。 HTTP/2 的传输效率也会越差。系统达到 2% 的丢包时. HTTP/1.1 的传输效率比 HTTP/2 表现更好。</p> <ul><li>TCP建立连接的延时
TCP 握手的过程也是影响传输效率的因素。 HTTP/1 和 HTTP/2 使用 TCP 协议来传输的，如果使用 HTTPS，还需要使用 TLS 协议进行安全传输。TLS 也需要一个握手过程。</li></ul> <p>建立 TCP，需要消耗 1.5 个 RTT 才能进行传输数据。</p> <p>进行 TLS。 TLS有两个版本 TLS1.2 和 TLS1.3，大致需要 1-2 个 RTT。</p> <p>传输数据之前，需要花掉 3～4 个 RTT。如果浏览器和服务器的物理距离较近，1个RTT大约花费 10 毫秒，如果较远，需要耗费 100 毫秒，也就是 300～400 毫秒的延迟。</p> <ul><li>TCP 协议僵化
上面的问题，都是出在 TCP 上。但是要改变 TCP 很难。</li></ul> <p>第一个是中间设备的僵化。需要在互联网的各处搭建各种设备，这些设备就是中间设备。
比如路由器、防火墙、NAT、交换机。依赖一些很少升级的软件，这些软件使用大量 TCP 特效。当新协议的数据包经过这些中间设备时，可能不理解包的内容，于是就会丢弃包。它是阻碍 TCP 更新的一大障碍。</p> <p>操作系统也是一大原因。TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新。</p> <h3 id="quic-协议"><a href="#quic-协议" class="header-anchor">#</a> QUIC 协议</h3> <p>发明了一个 TCP 和 UDP 之外的新的传输协议。但是中间设备只认识 TCP 和 UDP。</p> <p>HTTP/3 选择了一个折中的方法 --- UDP 协议，基于 UDP 实现类似 TCP 的多路数据流、传输可靠性等功能。</p> <ol start="2"><li>特点</li></ol> <ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。UDP 不提供可靠性的传输， 但 QUIC 在 UDP 的基础上增加一层来保证数据可靠性传输。提供数据包重传、用塞控制以及一些 TCP 中存在的特效。</li> <li>集成 TLS 加密功能。 QUIC 使用的是 TLS1.3，有更多的优点。其中最重要的是减少了握手所花费的 RTT 个数。</li> <li>实现了 HTTP/2 中的多路复用。QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，解决了 TCP 中队头阻塞的问题。</li> <li>实现了快速握手的功能。 QUIC 是基于 UDP 的，所以 QUIC 可以使用 0RTT 或 1-RTT 来建立连接。可以用最快的速度来发送和接收数据。</li></ul> <ol start="3"><li>挑战</li></ol> <ul><li><p>目前，服务器和浏览器端都没有对 HTTP/3 提供完全的支持。Chrome 虽然支持早，但是 Chrome 的 QUIC 和 官方的 QUIC 有较大的差异。</p></li> <li><p>部署 HTTP/3 ，系统内核对 UDP 的优化远远没有达到 TCP 的优化程度。</p></li> <li><p>中间设备僵化。这些设备对 UDP 的优化程度远远低于 TCP。使用 QUIC 协议，大约有 3% ～ 7% 的丢包率。</p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/http/assets/js/app.a9f7748e.js" defer></script><script src="/http/assets/js/2.fdc7410f.js" defer></script><script src="/http/assets/js/26.7f50fc9d.js" defer></script>
  </body>
</html>
