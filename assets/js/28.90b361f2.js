(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{441:function(a,t,e){"use strict";e.r(t);var r=e(62),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"代理缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理缓存"}},[a._v("#")]),a._v(" 代理缓存")]),a._v(" "),e("p",[a._v("对于 HTTP 缓存来说，如果每次客户端缓存都要到源服务器获取，会给源服务器的压力很大。")]),a._v(" "),e("p",[a._v("缓存代理，让代理服务器接管一部分的服务端的 HTTP 缓存，客户端缓存过期后就去代理缓存中获取，代理服务器过期之后才去源服务器获取。可以降低源服务器的压力。")]),a._v(" "),e("h2",{attrs:{id:"源服务器控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源服务器控制"}},[a._v("#")]),a._v(" 源服务器控制")]),a._v(" "),e("ol",[e("li",[a._v("private 和 public\nprivate 是禁止代理服务器缓存。\npublic 允许代理服务器缓存。")])]),a._v(" "),e("p",[a._v("如果是私密数据，放到代理服务器是非常危险的，别人可以直接访问代理服务器拿到数据。\n对于私密数据，应该使用 private 而不是 public。")]),a._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("p",[a._v("proxy-revalidate\nmust-revalidate 客户端缓存过期就去源服务器获取。\nproxy-revalidate 表示代理服务器缓存过去到源服务器获取。")])]),a._v(" "),e("li",[e("p",[a._v("s-maxage\n可以设置缓存在代理服务器中可以存放多久。\nCache-Control: public, max-age=1000, s-maxage=2000")])])]),a._v(" "),e("h2",{attrs:{id:"客户端控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#客户端控制"}},[a._v("#")]),a._v(" 客户端控制")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("max-stale\nmax-stale: 5 来对代理服务器上的缓存进行宽容处理，过期了不要紧，只要过期时间在 5 秒之内就可以从代理服务器获取。")])]),a._v(" "),e("li",[e("p",[a._v("min-fresh: 5 限制处理，在即将过期的前五秒之前的时间可以拿到，否则拿不到。")])]),a._v(" "),e("li",[e("p",[a._v("only-if-cached 表示客户端只会接受代理缓存，而不会接受服务器的响应。如果代理缓存无效，直接返回 504.")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);