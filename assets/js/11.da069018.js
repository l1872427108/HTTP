(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{425:function(t,a,v){"use strict";v.r(a);var _=v(62),T=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"http-1-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[t._v("#")]),t._v(" HTTP/1.1")]),t._v(" "),v("p",[t._v("不过随着技术的继续发展，需求也在不断迭代更新，很快 HTTP/1.0 也不能满足需求了，所以 HTTP/1.1 又在 HTTP/1.0 的基础之上做了大量的更新。")]),t._v(" "),v("h3",{attrs:{id:"改进持久连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#改进持久连接"}},[t._v("#")]),t._v(" 改进持久连接")]),t._v(" "),v("p",[t._v("HTTP/1.0 每进行一次 HTTP 通信, 都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段（如下图）。")]),t._v(" "),v("p",[t._v("由于之前通信的文件比较小，每个页面引入的也不多，所以这种传输形式没什么大问题。")]),t._v(" "),v("p",[t._v("到了后面，单个页面中的图片文件越来越多，有时候一个页面包含几百个外部引用的资源文件，如果在下载每个文件的时候，都建立 TCP 连接、传输数据和断开连接步骤，会增加大量的开销。")]),t._v(" "),v("p",[t._v("HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。")]),t._v(" "),v("p",[t._v("HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，减少了服务器额外的负担，并提升整体 HTTP 的请求时长。")]),t._v(" "),v("p",[t._v("持久连接在 HTTP/1.1 中是默认开启的，不需要专门为了持久连接去 HTTP 请求头设置信息， 如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。")]),t._v(" "),v("h3",{attrs:{id:"不成熟的-http-管线化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不成熟的-http-管线化"}},[t._v("#")]),t._v(" 不成熟的 HTTP 管线化")]),t._v(" "),v("p",[t._v("持久连接虽然能减少 TCP 的建立和断开次数, 但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。")]),t._v(" "),v("p",[t._v("HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术, 虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。")]),t._v(" "),v("p",[t._v("FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。")]),t._v(" "),v("h3",{attrs:{id:"提供虚拟主机的支持"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#提供虚拟主机的支持"}},[t._v("#")]),t._v(" 提供虚拟主机的支持")]),t._v(" "),v("p",[t._v("在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址, 因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展, 需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。")]),t._v(" "),v("p",[t._v("HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。")]),t._v(" "),v("p",[t._v("让互联网主机托管成为可能")]),t._v(" "),v("h3",{attrs:{id:"对动态生成的内容提供了完美支持"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对动态生成的内容提供了完美支持"}},[t._v("#")]),t._v(" 对动态生成的内容提供了完美支持")]),t._v(" "),v("p",[t._v("在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如 Content-Length: 90, 浏览器就可以根据设置的数据大小来接收数据。不过随着服务器的发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。")]),t._v(" "),v("p",[t._v("HTTP/1.1通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。")]),t._v(" "),v("h3",{attrs:{id:"增加了-put、delete-等新方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#增加了-put、delete-等新方法"}},[t._v("#")]),t._v(" 增加了 PUT、DELETE 等新方法")]),t._v(" "),v("h3",{attrs:{id:"cookie、安全机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cookie、安全机制"}},[t._v("#")]),t._v(" Cookie、安全机制")]),t._v(" "),v("p",[t._v("除此之外，HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。")]),t._v(" "),v("h3",{attrs:{id:"核心优化点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#核心优化点"}},[t._v("#")]),t._v(" 核心优化点")]),t._v(" "),v("ul",[v("li",[t._v("持久连接")]),t._v(" "),v("li",[t._v("浏览器为每个域名最多同时维护6个TCP持久连接。")]),t._v(" "),v("li",[t._v("使用 CDN 实现域名分片机制(将一个页面的资源利用多个域名下载，提高tcp并发数量)")])]),t._v(" "),v("p",[t._v("如果使用单个TCP的持久连接，下载 100 个资源所花费的时间为 100 * n * RTT; 通过分发 100 * n * RTT/(6 * CDN个数) 页面加载速度变快了不少")])])}),[],!1,null,null,null);a.default=T.exports}}]);