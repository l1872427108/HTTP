(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{432:function(v,_,t){"use strict";t.r(_);var a=t(62),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"https让数据传输更安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https让数据传输更安全"}},[v._v("#")]),v._v(" HTTPS让数据传输更安全")]),v._v(" "),t("h3",{attrs:{id:"http的隐患"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http的隐患"}},[v._v("#")]),v._v(" HTTP的隐患")]),v._v(" "),t("p",[v._v("起初设计的 HTTP 协议的目的很单纯，就是为了传输超文本文件，也没有太强的加密传输的数据需求，所以 HTTP 保持明文传输数据的特征。")]),v._v(" "),t("p",[v._v("所以，在传输过程中的每一个环节，数据都有可能背窃取或串改。浏览器和服务器之间还可能有一个中间人。")]),v._v(" "),t("p",[v._v("在将 HTTP 数据交给 TCP 层之后，数据会经过用户电脑、WiFi路由器、运营商和目标服务器。")]),v._v(" "),t("h3",{attrs:{id:"在-http-协议栈中引入安全层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在-http-协议栈中引入安全层"}},[v._v("#")]),v._v(" 在 HTTP 协议栈中引入安全层")]),v._v(" "),t("p",[v._v("在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密。")]),v._v(" "),t("p",[v._v("对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 内容进行解密操作。")]),v._v(" "),t("h3",{attrs:{id:"如何加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何加密"}},[v._v("#")]),v._v(" 如何加密")]),v._v(" "),t("ol",[t("li",[v._v("使用对称加密\n加密和解密都使用相同的密钥, 需要知道加密方式和密钥。")])]),v._v(" "),t("ul",[t("li",[v._v("浏览器发送它支持的加密套件和一个随机数 client-random.")]),v._v(" "),t("li",[v._v("服务器会从加密套件中选取一个加密套件，然后也生成一个随机数 service-random, 并一起返回给浏览器。")]),v._v(" "),t("li",[v._v("最后浏览器和服务器分别返回确认信息。")])]),v._v(" "),t("p",[v._v("当浏览器和服务器都有 client-random 和 service-random 。根据相同的方法将 clinet-random 和 service-random 混合起来生成一个密钥 master secret , 有了密钥和 加密套件就可以进行数据的加密传输了。")]),v._v(" "),t("p",[v._v("但是传输 client-random 和 service-random 的过程是明文的, 随机数合成密钥的算法是公开的，黑客拿到随机数就可以拿到密钥。")]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[v._v("使用非对称加密\n非对称加密算法有 A、B 两把密钥，如果用 A 密钥加密，只能使用 B 密钥来解密； 反过来，如果 B 密钥加密，只能用 A 密钥 来解密.")])]),v._v(" "),t("ul",[t("li",[v._v("浏览器发送加密套件列表给服务器。")]),v._v(" "),t("li",[v._v("服务器选择一个加密套件，服务器将公钥和加密套件一起发送给浏览器，服务器自己留有私钥。")]),v._v(" "),t("li",[v._v("最后浏览器和服务器返回确认消息。")])]),v._v(" "),t("p",[v._v("在浏览器发送数据给服务器端时，可以使用该公钥来加密数据。由于公钥加密的数据只能服务器私钥来解密。黑客就无法使用公钥来解密了。")]),v._v(" "),t("p",[v._v("非对称加密的效率太低。影响到加解密数据的速度。影响用户打开时间。")]),v._v(" "),t("p",[v._v("无法保证服务器发送给浏览器的数据的安全。黑客截获公钥, 服务器只能采用私钥来加密，私钥加密只有公钥能解密，就不能保证服务器端数据的安全.")]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[v._v("对称加密和非对称加密结合\n在传输数据阶段使用对称加密，对称加密的密钥采用非对称加密来传输。")])]),v._v(" "),t("ul",[t("li",[v._v("浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random.")]),v._v(" "),t("li",[v._v("服务器保存随机数 client-random, 选择对称加密和非对称加密的套件，然后生成随机数 service-random, 向浏览器发送加密套件、service-random 和 公钥。")]),v._v(" "),t("li",[v._v("浏览器保存公钥，生成随机数 pre-master, 然后利用 公钥 对 pre-master 加密，并向服务器发送加密后的数据；")]),v._v(" "),t("li",[v._v("最后服务器拿出自己的私钥，解密出 pre-master 数据，返回确认消息。")])]),v._v(" "),t("p",[v._v("服务器和浏览器有了共同的 client-random、service-random 和 pre-master. 然后服务器和浏览器使用这三组随机数生成生成对称密钥。最终服务器和浏览器生成的密钥也是相同的。")]),v._v(" "),t("p",[v._v("pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了。")]),v._v(" "),t("h3",{attrs:{id:"添加数字证书"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#添加数字证书"}},[v._v("#")]),v._v(" 添加数字证书")]),v._v(" "),t("p",[v._v("通过对称加密和非对称加密结合的方式，实现了数据的加密传输。如果黑客通过 DNS 劫持将官网 IP 地址替换成黑客的 IP 地址，这样访问的其实是黑客的服务器，黑客就可以在自己的服务器上实现公钥和私钥。浏览器确不知道访问的是黑客的站点。")]),v._v(" "),t("p",[v._v("要证明这个服务器就是它自己，需要使用权威机构颁发的证书，这个权威机构称为 CA，颁发的证书就是数字证书。")]),v._v(" "),t("p",[v._v("数字证书的作用：1. 通过数字证书证明服务器的身份。2. 数字证书里面包含服务器公钥。")]),v._v(" "),t("p",[v._v("服务器不会直接返回公钥给浏览器，而是返回数字证书，而公钥包含在数字证书中。")]),v._v(" "),t("p",[v._v("浏览器端多一个验证证书的操作，通过之后，才可以继续。")]),v._v(" "),t("p",[v._v("实现了服务器的身份认证功能。")]),v._v(" "),t("h3",{attrs:{id:"如何申请数字证书"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何申请数字证书"}},[v._v("#")]),v._v(" 如何申请数字证书")]),v._v(" "),t("ul",[t("li",[v._v("首先官网需要准备一套私钥和公钥，私钥留着自己使用。")]),v._v(" "),t("li",[v._v("官网向 CA 机构提交公钥、公司、站点等信息并等待认真，这个认证过程可能是收费的；")]),v._v(" "),t("li",[v._v("CA 通过线上、线下多种渠道来验证官网提供信息的真实性，如果合法；")]),v._v(" "),t("li",[v._v("如果审核通过，CA 机构会拿出自己的私钥，对表单的内容进行一连串的操作，包括了对明文资料进行 Hash 计算得出信息摘要，利用 CA 的私钥加密信息摘要得出数字签名，最后将数字签名也写在表单上，返回给官网。")])]),v._v(" "),t("h3",{attrs:{id:"浏览器如何验证数字证书"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器如何验证数字证书"}},[v._v("#")]),v._v(" 浏览器如何验证数字证书")]),v._v(" "),t("ol",[t("li",[v._v("浏览器需要验证证书的有效性。")]),v._v(" "),t("li",[v._v("浏览器需要验证数字证书是否被吊销了。两种方式，一种是下载吊销证书列表 CRL. 第二种是在线验证方式 - OCSP .")]),v._v(" "),t("li",[v._v("验证数字证书是否是 CA 版本。 首先，浏览器利用证书的原始信息计算出信息摘要；然后，利用 CA 的公钥来解密数字证书中的数字签名，解密出来的信息也是信息摘要； 最后，判断两个信息摘要是否相等。")])]),v._v(" "),t("h3",{attrs:{id:"浏览器如何获取到-ca-公钥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器如何获取到-ca-公钥"}},[v._v("#")]),v._v(" 浏览器如何获取到 CA 公钥")]),v._v(" "),t("p",[v._v("部署服务时，除了部署当前的数字证书，还需要部署 CA 机构的数字证书，CA 机构的数字证书就包括了 CA 的公钥以及 CA 机构的一些基础信息。")]),v._v(" "),t("p",[v._v("官网服务器就有两个数字证书：给官网域名的数字证书 和 给官网签名的CA机构的数字证书。")]),v._v(" "),t("p",[v._v("在建立 HTTPS 链接时，服务器会将这两个证书一同发送给浏览器，浏览器就获得了 CA 的公钥。")]),v._v(" "),t("p",[v._v("就可以获取 CA 的公钥来验证数字证书的可靠性。")]),v._v(" "),t("h3",{attrs:{id:"验证-ca-机构的合法性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#验证-ca-机构的合法性"}},[v._v("#")]),v._v(" 验证 CA 机构的合法性")]),v._v(" "),t("p",[v._v("将颁发证书的机构划分为两种类型，根 CA(Root CAs)和中间 CA(Intermediates CAs)。 通常申请者都是向中间 CA 去申请证书的，而根 CA 作用就是给中间 CA 做认证，一个根 CA 会认证很多中间的 CA，而这些中间 CA 又可以去认证其他的中间 CA。")]),v._v(" "),t("p",[v._v("这样就形成于一条证书链，可以沿着证书链从用户证书追溯到根证书。")]),v._v(" "),t("h3",{attrs:{id:"如何验证根证书的合法性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何验证根证书的合法性"}},[v._v("#")]),v._v(" 如何验证根证书的合法性")]),v._v(" "),t("p",[v._v("浏览器的判断策略很简单，它只是简单地判断这个根证书在不在操作系统里面，如果在，那么浏览器就认为这个根证书是合法的，如果不在，那么就是非法的。")]),v._v(" "),t("p",[v._v("某个机构想要成为根 CA，并让它的根证书内置到操作系统中，那么这个机构首先要通过 WebTrust 国际安全审计认证。")])])}),[],!1,null,null,null);_.default=r.exports}}]);